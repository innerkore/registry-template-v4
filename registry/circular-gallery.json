{
  "name": "circular-gallery",
  "type": "registry:component",
  "description": "TypeScript component (transformed from src/components/ui/circular-gallery.tsx)",
  "title": "Circular Gallery",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "src/components/ui/circular-gallery.tsx",
      "type": "registry:ui",
      "content": "import { useRef, useEffect } from \"react\";\nimport Link from \"@/components/Link\";\nimport {\n  Renderer,\n  Camera,\n  Transform,\n  Plane,\n  Mesh,\n  Program,\n  Texture,\n} from \"ogl\";\n\ntype GL = Renderer[\"gl\"];\n\ninterface TitleProps {\n  gl: GL;\n  plane: Mesh;\n  renderer: Renderer;\n  text: string;\n  textColor?: string;\n  font?: string;\n}\n\nclass Title {\n  gl: GL;\n  plane: Mesh;\n  renderer: Renderer;\n  text: string;\n  textColor: string;\n  font: string;\n  mesh!: Mesh;\n\n  constructor({\n    gl,\n    plane,\n    renderer,\n    text,\n    textColor = \"#545050\",\n    font = \"30px sans-serif\",\n  }: TitleProps) {\n    this.gl = gl;\n    this.plane = plane;\n    this.renderer = renderer;\n    this.text = text;\n    this.textColor = textColor;\n    this.font = font;\n    this.createMesh();\n  }\n\n  createMesh() {\n    const { texture, width, height } = createTextTexture(\n      this.gl,\n      this.text,\n      this.font,\n      this.textColor\n    );\n    const geometry = new Plane(this.gl);\n    const program = new Program(this.gl, {\n      vertex: `\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 modelViewMatrix;\n        uniform mat4 projectionMatrix;\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragment: `\n        precision highp float;\n        uniform sampler2D tMap;\n        varying vec2 vUv;\n        void main() {\n          vec4 color = texture2D(tMap, vUv);\n          if (color.a < 0.1) discard;\n          gl_FragColor = color;\n        }\n      `,\n      uniforms: { tMap: { value: texture } },\n      transparent: true,\n    });\n    this.mesh = new Mesh(this.gl, { geometry, program });\n    const aspect = width / height;\n    const textHeightScaled = this.plane.scale.y * 0.15;\n    const textWidthScaled = textHeightScaled * aspect;\n    this.mesh.scale.set(textWidthScaled, textHeightScaled, 1);\n    this.mesh.position.y =\n      -this.plane.scale.y * 0.5 - textHeightScaled * 0.5 - 0.05;\n    this.mesh.setParent(this.plane);\n  }\n}\n\ninterface ScreenSize {\n  width: number;\n  height: number;\n}\n\ninterface Viewport {\n  width: number;\n  height: number;\n}\n\ninterface MediaProps {\n  geometry: Plane;\n  gl: GL;\n  image: string;\n  index: number;\n  length: number;\n  renderer: Renderer;\n  scene: Transform;\n  screen: ScreenSize;\n  text: string;\n  viewport: Viewport;\n  bend: number;\n  textColor: string;\n  borderRadius?: number;\n  font?: string;\n}\n\nclass Media {\n  geometry: Plane;\n  gl: GL;\n  image: string;\n  index: number;\n  length: number;\n  renderer: Renderer;\n  scene: Transform;\n  screen: ScreenSize;\n  text: string;\n  viewport: Viewport;\n  bend: number;\n  textColor: string;\n  borderRadius: number;\n  font?: string;\n  plane!: Mesh;\n  title!: Title;\n\n  constructor({\n    geometry,\n    gl,\n    image,\n    index,\n    length,\n    renderer,\n    scene,\n    screen,\n    text,\n    viewport,\n    bend,\n    textColor,\n    borderRadius = 0,\n    font,\n  }: MediaProps) {\n    this.geometry = geometry;\n    this.gl = gl;\n    this.image = image;\n    this.index = index;\n    this.length = length;\n    this.renderer = renderer;\n    this.scene = scene;\n    this.screen = screen;\n    this.text = text;\n    this.viewport = viewport;\n    this.bend = bend;\n    this.textColor = textColor;\n    this.borderRadius = borderRadius;\n    this.font = font;\n    this.createShader();\n    this.createMesh();\n    this.createTitle();\n  }\n\n  createShader() {\n    const texture = new Texture(this.gl, { generateMipmaps: false });\n    this.program = new Program(this.gl, {\n      depthTest: false,\n      depthWrite: false,\n      vertex: `\n        precision highp float;\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 modelViewMatrix;\n        uniform mat4 projectionMatrix;\n        uniform float uTime;\n        uniform float uSpeed;\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          vec3 p = position;\n          p.z = (sin(p.x * 4.0 + uTime) * 1.5 + cos(p.y * 2.0 + uTime) * 1.5) * (0.1 + uSpeed * 0.5);\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n        }\n      `,\n      fragment: `\n        precision highp float;\n        uniform vec2 uImageSizes;\n        uniform vec2 uPlaneSizes;\n        uniform sampler2D tMap;\n        uniform float uBorderRadius;\n        varying vec2 vUv;\n        void main() {\n          vec2 ratio = vec2(\n            min((uPlaneSizes.x / uPlaneSizes.y) / (uImageSizes.x / uImageSizes.y), 1.0),\n            min((uPlaneSizes.y / uPlaneSizes.x) / (uImageSizes.y / uImageSizes.x), 1.0)\n          );\n          vec2 uv = vec2(\n            vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n            vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n          );\n          vec4 color = texture2D(tMap, uv);\n          float d = roundedBoxSDF(vUv - 0.5, vec2(0.5 - uBorderRadius), uBorderRadius);\n          if(d > 0.0) {\n            discard;\n          }\n          gl_FragColor = vec4(color.rgb, 1.0);\n        }\n      `,\n      uniforms: {\n        tMap: { value: texture },\n        uPlaneSizes: { value: [0, 0] },\n        uImageSizes: { value: [0, 0] },\n        uSpeed: { value: 0 },\n        uTime: { value: 100 * Math.random() },\n        uBorderRadius: { value: this.borderRadius },\n      },\n      transparent: true,\n    });\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    img.src = this.image;\n    img.onload = () => {\n      texture.image = img;\n      this.program.uniforms.uImageSizes.value = [\n        img.naturalWidth,\n        img.naturalHeight,\n      ];\n    };\n  }\n\n  createMesh() {\n    this.plane = new Mesh(this.gl, {\n      geometry: this.geometry,\n      program: this.program,\n    });\n    this.plane.setParent(this.scene);\n  }\n\n  createTitle() {\n    this.title = new Title({\n      gl: this.gl,\n      plane: this.plane,\n      renderer: this.renderer,\n      text: this.text,\n      textColor: this.textColor,\n      font: this.font,\n    });\n  }\n\n  update(scroll: { current: number; last: number }, direction: \"right\" | \"left\") {\n    this.plane.position.x = this.x - scroll.current - this.extra;\n    const x = this.plane.position.x;\n    const H = this.viewport.width / 2;\n    if (this.bend === 0) {\n      this.plane.position.y = 0;\n      this.plane.rotation.z = 0;\n    } else {\n      const B_abs = Math.abs(this.bend);\n      const R = (H * H + B_abs * B_abs) / (2 * B_abs);\n      const effectiveX = Math.min(Math.abs(x), H);\n      const arc = R - Math.sqrt(R * R - effectiveX * effectiveX);\n      if (this.bend > 0) {\n        this.plane.position.y = -arc;\n        this.plane.rotation.z = -Math.sign(x) * Math.asin(effectiveX / R);\n      } else {\n        this.plane.position.y = arc;\n        this.plane.rotation.z = Math.sign(x) * Math.asin(effectiveX / R);\n      }\n    }\n    this.speed = scroll.current - scroll.last;\n    this.program.uniforms.uTime.value += 0.04;\n    this.program.uniforms.uSpeed.value = this.speed;\n    const planeOffset = this.plane.scale.x / 2;\n    const viewportOffset = this.viewport.width / 2;\n    this.isBefore = this.plane.position.x + planeOffset < -viewportOffset;\n    this.isAfter = this.plane.position.x - planeOffset > viewportOffset;\n    if (direction === \"right\" && this.isBefore) {\n      this.extra -= this.widthTotal;\n      this.isBefore = this.isAfter = false;\n    }\n    if (direction === \"left\" && this.isAfter) {\n      this.extra += this.widthTotal;\n      this.isBefore = this.isAfter = false;\n    }\n  }\n\n  onResize({ screen, viewport }: { screen?: ScreenSize; viewport?: Viewport } = {}) {\n    if (screen) this.screen = screen;\n    if (viewport) {\n      this.viewport = viewport;\n      if (this.plane.program.uniforms.uViewportSizes) {\n        this.plane.program.uniforms.uViewportSizes.value = [\n          this.viewport.width,\n          this.viewport.height,\n        ];\n      }\n    }\n    this.scale = this.screen.height / 1500;\n    this.plane.scale.y =\n      (this.viewport.height * (900 * this.scale)) / this.screen.height;\n    this.plane.scale.x =\n      (this.viewport.width * (700 * this.scale)) / this.screen.width;\n    this.plane.program.uniforms.uPlaneSizes.value = [\n      this.plane.scale.x,\n      this.plane.scale.y,\n    ];\n    this.padding = 2;\n    this.width = this.plane.scale.x + this.padding;\n    this.widthTotal = this.width * this.length;\n    this.x = this.width * this.index;\n  }\n}\n\ninterface AppConfig {\n  items?: { image: string; text: string }[];\n  bend?: number;\n  textColor?: string;\n  borderRadius?: number;\n  font?: string;\n}\n\nclass App {\n  container: HTMLElement;\n  scroll: {\n    ease: number;\n    current: number;\n    target: number;\n    last: number;\n    position?: number;\n  };\n  renderer!: Renderer;\n  gl!: GL;\n  camera!: Camera;\n  scene!: Transform;\n  planeGeometry!: Plane;\n  medias: Media[] = [];\n  mediasImages: { image: string; text: string }[] = [];\n  screen!: { width: number; height: number };\n  viewport!: { width: number; height: number };\n  raf: number = 0;\n\n  constructor(\n    container: HTMLElement,\n    {\n      items,\n      bend = 1,\n      textColor = \"#ffffff\",\n      borderRadius = 0,\n      font = \"bold 30px DM Sans\",\n    }: AppConfig\n  ) {\n    this.container = container;\n    this.scroll = { ease: 0.05, current: 0, target: 0, last: 0 };\n    this.createRenderer();\n    this.createCamera();\n    this.createScene();\n    this.onResize();\n    this.createGeometry();\n    this.createMedias(items, bend, textColor, borderRadius, font);\n    this.update();\n    this.addEventListeners();\n  }\n\n  createRenderer() {\n    this.renderer = new Renderer({ alpha: true });\n    this.gl = this.renderer.gl;\n    this.container.appendChild(this.renderer.gl.canvas as HTMLCanvasElement);\n  }\n\n  createCamera() {\n    this.camera = new Camera(this.gl);\n    this.camera.fov = 45;\n    this.camera.position.z = 20;\n  }\n\n  createScene() {\n    this.scene = new Transform();\n  }\n\n  createGeometry() {\n    this.planeGeometry = new Plane(this.gl, {\n      heightSegments: 50,\n      widthSegments: 100,\n    });\n  }\n\n  createMedias(\n    items: { image: string; text: string }[] | undefined,\n    bend: number = 1,\n    textColor: string,\n    borderRadius: number,\n    font: string\n  ) {\n    const defaultItems = [\n      {\n        image: `https://picsum.photos/seed/1/800/600?grayscale`,\n        text: \"Bridge\",\n      },\n      {\n        image: `https://picsum.photos/seed/2/800/600?grayscale`,\n        text: \"Desk Setup\",\n      },\n    ];\n    const galleryItems = items && items.length ? items : defaultItems;\n    this.mediasImages = galleryItems.concat(galleryItems);\n    this.medias = this.mediasImages.map((data, index) => {\n      return new Media({\n        geometry: this.planeGeometry,\n        gl: this.gl,\n        image: data.image,\n        index,\n        length: this.mediasImages.length,\n        renderer: this.renderer,\n        scene: this.scene,\n        screen: this.screen,\n        text: data.text,\n        viewport: this.viewport,\n        bend,\n        textColor,\n        borderRadius,\n        font,\n      });\n    });\n  }\n\n  onResize() {\n    this.screen = {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight,\n    };\n    this.renderer.setSize(this.screen.width, this.screen.height);\n    this.camera.perspective({\n      aspect: this.screen.width / this.screen.height,\n    });\n    const fov = (this.camera.fov * Math.PI) / 180;\n    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;\n    const width = height * this.camera.aspect;\n    this.viewport = { width, height };\n    if (this.medias) {\n      this.medias.forEach((media) =>\n        media.onResize({ screen: this.screen, viewport: this.viewport })\n      );\n    }\n  }\n\n  update() {\n    this.scroll.current = lerp(\n      this.scroll.current,\n      this.scroll.target,\n      this.scroll.ease\n    );\n    const direction = this.scroll.current > this.scroll.last ? \"right\" : \"left\";\n    if (this.medias) {\n      this.medias.forEach((media) => media.update(this.scroll, direction));\n    }\n    this.renderer.render({ scene: this.scene, camera: this.camera });\n    this.scroll.last = this.scroll.current;\n    this.raf = window.requestAnimationFrame(this.update.bind(this));\n  }\n\n  addEventListeners() {\n    window.addEventListener(\"resize\", this.onResize.bind(this));\n    window.addEventListener(\"mousewheel\", this.onWheel.bind(this));\n    window.addEventListener(\"wheel\", this.onWheel.bind(this));\n    window.addEventListener(\"mousedown\", this.onTouchDown.bind(this));\n    window.addEventListener(\"mousemove\", this.onTouchMove.bind(this));\n    window.addEventListener(\"mouseup\", this.onTouchUp.bind(this));\n    window.addEventListener(\"touchstart\", this.onTouchDown.bind(this));\n    window.addEventListener(\"touchmove\", this.onTouchMove.bind(this));\n    window.addEventListener(\"touchend\", this.onTouchUp.bind(this));\n  }\n\n  destroy() {\n    window.cancelAnimationFrame(this.raf);\n    window.removeEventListener(\"resize\", this.onResize.bind(this));\n    window.removeEventListener(\"mousewheel\", this.onWheel.bind(this));\n    window.removeEventListener(\"wheel\", this.onWheel.bind(this));\n    window.removeEventListener(\"mousedown\", this.onTouchDown.bind(this));\n    window.removeEventListener(\"mousemove\", this.onTouchMove.bind(this));\n    window.removeEventListener(\"mouseup\", this.onTouchUp.bind(this));\n    window.removeEventListener(\"touchstart\", this.onTouchDown.bind(this));\n    window.removeEventListener(\"touchmove\", this.onTouchMove.bind(this));\n    window.removeEventListener(\"touchend\", this.onTouchUp.bind(this));\n    if (\n      this.renderer &&\n      this.renderer.gl &&\n      this.renderer.gl.canvas.parentNode\n    ) {\n      this.renderer.gl.canvas.parentNode.removeChild(\n        this.renderer.gl.canvas as HTMLCanvasElement\n      );\n    }\n  }\n}\n\ninterface CircularGalleryProps {\n  items?: { image: string; text: string }[];\n  bend?: number;\n  textColor?: string;\n  borderRadius?: number;\n  font?: string;\n  backgroundImage?: string;\n  backgroundColor?: string;\n}\n\nconst CircularGallery = ({\n  items,\n  bend,\n  textColor,\n  borderRadius,\n  font,\n  backgroundImage,\n  backgroundColor,\n}: CircularGalleryProps) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const app = new App(containerRef.current, {\n      items,\n      bend,\n      textColor,\n      borderRadius,\n      font,\n    });\n    return () => {\n      app.destroy();\n    };\n  }, [items, bend, textColor, borderRadius, font]);\n  return (\n    <div\n      className=\"w-full h-full overflow-hidden cursor-grab active:cursor-grabbing\"\n      style={{ backgroundImage: `url(${backgroundImage})`, backgroundColor }}\n      ref={containerRef}\n    />\n  );\n};\n\nexport const Component = CircularGallery;"
    }
  ],
  "meta": {
    "component_name": "CircularGallery",
    "component_path": "src/components/ui/circular-gallery.tsx",
    "props": "CircularGalleryProps",
    "props_path": "src/components/ui/circular-gallery.tsx",
    "original_file": "src/components/ui/circular-gallery.tsx",
    "transformed_at": "2025-09-19T17:28:00.855157",
    "category": "gallery",
    "tags": [
      "gallery",
      "content-container",
      "visual-dominant",
      "dynamic-content",
      "responsive-mobile"
    ],
    "variations": [],
    "public_ready": true,
    "public_ready_updated_at": "2025-09-19T17:29:18.296951",
    "imported_from": "https://21st.dev/r/davidhzdev/circular-gallery"
  }
}